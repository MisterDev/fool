# Sintassi

# nometest:
# - codice
# - risultato (stringa)

test1 - Varasm:
-   let
      int y = 5 ;
    in
      print( y );

-   "5"

test2 - Sum:
-   let
      int y = 5 + 2;
    in
      print( y );
-   "7"

test3 - Nested Functions:
-   let
        int x = 5;
        int f ()
            let
              int g()
                x
              ;
            in
              g()
        ;
    in
        print(f());
-   "5"

test4 - ITE Incombatible Types:
-   let
        int y = 5 + 2 ;
        bool f (int n, int m)
            let
                int x = m;
            in
                x == y;
    in
        print(if f(y, 8) then {false} else {10});
-   "Error: \"Incompatible types in then else branches\" at line 1, column 77."

test5 - ITE e Times:
-   let
        int geee(int n)
            n + 1;
        int foo(int n)
            if (n == 0) then { 1 } else { n * geee(n-1) };
    in
        print(foo(3));
-   "9"

test6 - Scopes Error:
-   let
        int foo(int n)
            let
                int gee(int n) 1;
            in
                if (n==0) then { 1 } else { n * gee(n-1) };
    in
        print(gee(3));
-   "Id gee not declared"

test7 - Simple Print:
-   print(1);
-   "1"

# Test one method without args call
test8 - MethodCall with 0 Arguments:
-   class Numero {
        int uno() 1;
    };
    let
        Numero num = new Numero;
    in
        print(num.uno());
-   "1"

# Test two method without args calls
test9 - 2 MethodCall with 0 Arguments:
-   class Numeri {
        int uno() 1;
        int due() 2;
    };
    let
        Numeri num = new Numeri;
    in
        print(num.uno() + num.due());
-   "3"

# Test one method arguments
test10 - MethodCall with 1 Argument:
-   class Numero {
        int id(int x) x;
    };
    let
        Numero num = new Numero;
    in
        print(num.id(1));
-   "1"

# Test two method's arguments
test11 - MethodCall with 2 Arguments:
-   class Numero {
        int plus(int x, int y) x + y;
    };
    let
        Numero num = new Numero;
    in
        print(num.plus(3, 5));
-   "8"

# Test wrong method's argument
test12 - MethodCall with wrong Argument:
-   class Numero {
        int plus(int x, int y) x + y;
    };
    let
        Numero num = new Numero;
    in
        print(num.plus(false, 5));
-   "Error: \"Wrong type for 1-th parameter in the invocation of plus\" at line 1, column 90."

# Test field
test13 - Class Attribute:
-   class Numero(int x) {
        int getX() x;
    };
    let
        Numero num = new Numero(2);
    in
        print(num.getX());
-   "2"

# Test wrong constructor
test14 - Wrong Type in Constructor Call:
-   class Numero(int x) {
        int getX() x;
    };
    let
        Numero num = new Numero(false);
    in
        print(num.getX());
-   "Error: \"Wrong type for 1-th parameter in the invocation of Numero constructor\" at line 1, column 56."

test15 - Name Hell:
-   class X(int x) {
        int x() x;
    };
    let
        X x = new X(2);
    in
        print(x.x());
-   "2"

test16 - Name Hell with Function Parameters:
-   class X(int x) {
        int x(int x) x;
    };
    let
        X x = new X(2);
    in
        print(x.x(1));
-   "1"

test17 - Dispatch Table:
-   class Numero(int x) {
        int getX() x;
        int getY() x;
    }
    class NumeroI implements Numero(int x) {
        int getY() x;
    }
    class NumeroV implements Numero(int x) {
        int getX() x;
        int getY() x;
    }
    class NumeroX implements NumeroV(int x) {
        int getX() x;
    };
    let
        Numero num = new Numero(2);
    in
        print(num.getX());
-   "2"

test18 - Let Inside Func Redefines Function Param:
-   let
        int foo(int n)
            let
                int n = n;
            in
                print(n);
    in
        print(foo(3));
- "multiple definitions of variable: n"

test19 - Superclass object with subtype instance:
-   class A
    class B implements A;
    let
        A a = new B;
    in
        print(1);
- "1"

test20 - Method overriding in subclass:
-   class A {
        int f() 1;
    }
    class B implements A {
        int f() 2;
    };
    let
        A a = new A;
        A b = new B;
    in
        print(a.f() + b.f());
- "3"

test21 - Call method on object returned by method:
-   class Numero (int x) {
        Numero uno() new Numero(4);
        int due() x;
    };
    let
        Numero num = new Numero(2);
        Numero num2 = num.uno();
    in
        print(num2.due());
- "4"

test22 - Method calling another method:
-   class Numero (int x){
        int uno() x;
        int due() this.uno();
    };
    let
        Numero num = new Numero(2);
    in
        print(num.due());
- "2"

test23 - Function returning an object:
-   class Numero (int x) {
        int getNum() x;
    };
    let
        Numero uno() new Numero(1);
        Numero num = uno();
    in
        print(num.getNum());
-   "1"

test24 - Scope Hell inside Class:
-   class Numero (int x) {
        int getX()
            let
                int y = 3;
            in
                x;
        int getRedefinedX()
            let
                int x = 3;
            in
                x;
        int getParamX(int x)
            x;
        int getXInsideFun()
            let
                int f() x;
            in
                f();
    };
    let
        Numero num = new Numero(5);
    in
        print(num.getX() + num.getRedefinedX() + num.getParamX(10) + num.getXInsideFun());
-   "23"

test25 - Using this as expression:
-   class Numero (int x) {
        Numero getThis() this;
        int getX() x;
    };
    let
        Numero num = new Numero(8);
        Numero num2 = num.getThis();
    in
        print(num2.getX());
- "8"